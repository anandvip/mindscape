<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindscape Co-Creator</title>
    <style>
        :root { --bg-main: #1A202C; --bg-gradient: linear-gradient(135deg, #1A202C 0%, #2D3748 100%); --text-primary: #E2E8F0; --text-secondary: #A0AEC0; --surface-color: rgba(45, 55, 72, 0.9); --surface-border: rgba(226, 232, 240, 0.2); --primary-color: #805AD5; --glow-color: rgba(128, 90, 213, 0.4); --success-color: #48BB78; --warning-color: #ED8936; --danger-color: #E53E3E; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-main); color: var(--text-primary); }
        .app-container { max-width: 1200px; margin: 0 auto; background: var(--bg-gradient); min-height: 100vh; }
        .header { text-align: center; padding: 30px 20px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); border-bottom: 1px solid var(--surface-border); }
        .header h1 { font-size: clamp(1.5rem, 5vw, 2.5rem); }
        .section { padding: 0 20px; margin-bottom: 40px; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .section-title { font-size: 1.4rem; font-weight: 600; }
        .modal-layer { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 32, 44, 0.9); backdrop-filter: blur(8px); z-index: 1000; overflow-y: auto; padding: 20px; animation: fadeIn 0.3s; align-items: center; justify-content: center; }
        .modal-layer.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: var(--surface-color); border-radius: 12px; border: 1px solid var(--surface-border); max-width: 600px; width: 100%; animation: slideIn 0.3s; }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { padding: 20px; border-bottom: 1px solid var(--surface-border); display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 1.3rem; }
        .modal-close { background:none; border:none; color:var(--text-secondary); font-size:1.5rem; cursor:pointer; }
        .modal-body { padding: 20px; }
        .scroll-container { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; scroll-behavior: smooth; padding-bottom: 15px; scrollbar-width: none; gap: 15px; }
        .scroll-container::-webkit-scrollbar { display: none; }
        .card { flex-shrink: 0; width: min(calc(100vw - 55px), 400px); scroll-snap-align: center; background: var(--surface-color); border-radius: 12px; padding: 15px; border: 1px solid var(--surface-border); }
        .pattern-card.focused { box-shadow: 0 0 20px var(--glow-color); border-color: var(--primary-color); transform: scale(1.02); }
        .btn { padding: 8px 16px; border: none; border-radius: 8px; font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; }
        .btn-small { padding: 6px 12px; font-size: 0.7rem; }
        .btn-primary { background: linear-gradient(135deg, #805AD5 0%, #553C9A 100%); color: white; }
        .btn-danger { background: var(--danger-color); color: white; }
        .toast-container { position: fixed; top: 20px; right: 20px; z-index: 2000; display: flex; flex-direction: column; gap: 10px; }
        .toast { padding: 12px 16px; border-radius: 8px; color: white; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: toastSlide 0.3s ease, toastFade 3s 0.3s ease forwards; }
        .toast-success { background: var(--success-color); } .toast-warning { background: var(--warning-color); }
        @keyframes toastSlide { from { transform: translateX(100%); } to { transform: translateX(0); } }
        @keyframes toastFade { 0%, 85% { opacity: 1; } 100% { opacity: 0; } }
        @media (min-width: 768px) { .scroll-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); overflow-x: visible; } }
    </style>
</head>
<body>
    <div id="app-container" class="app-container"></div>
    <div id="modal-container"></div>
    <div id="toast-container" class="toast-container" aria-live="polite"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    let state;
    const elements = {};
    const observers = new Map();
    const CONTEXT_OPTIONS = ['Work', 'Home', 'Commute', 'Social', 'Media', 'Alone'];
    const MAX_ENCOUNTERS = 500;
    const STORAGE_KEY = 'mindscape-co-creator-v2';

    const sanitize = (str) => { const d=document.createElement('div'); d.textContent=str?.trim().substring(0, 200)||''; return d.innerHTML; };
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    
    const toast = {
        show(message, type = 'success', duration = 3000) {
            const el = document.createElement('div');
            el.className = `toast toast-${type}`;
            el.textContent = sanitize(message);
            elements.toastContainer.appendChild(el);
            setTimeout(() => el.remove(), duration);
        },
        success: (msg) => toast.show(msg, 'success'),
        warning: (msg) => toast.show(msg, 'warning'),
    };

    const modal = {
        stack: [],
        lastFocusedElement: null,
        open(config) {
            this.lastFocusedElement = document.activeElement;
            const modalData = { id: generateId(), ...config };
            this.stack.push(modalData);
            this.render();
        },
        close() {
            this.stack.pop();
            this.render();
            this.lastFocusedElement?.focus();
        },
        render() {
            const top = this.stack[this.stack.length - 1];
            if (top) {
                elements.modalContainer.innerHTML = `<div class="modal-layer active" role="dialog" aria-modal="true"><div class="modal-content"><div class="modal-header"><h3 class="modal-title">${sanitize(top.title)}</h3><button class="modal-close" data-action="close-modal">Ã—</button></div><div class="modal-body">${top.content}</div></div></div>`;
                top.onOpen?.(elements.modalContainer.querySelector('.modal-content'));
                this.trapFocus();
            } else {
                elements.modalContainer.innerHTML = '';
            }
        },
        trapFocus() {
            const modalEl = elements.modalContainer.querySelector('.modal-layer');
            if (!modalEl) return;
            const focusable = modalEl.querySelectorAll('button, [href], input, textarea, [tabindex]:not([tabindex="-1"])');
            const first = focusable[0], last = focusable[focusable.length - 1];
            first?.focus();
            modalEl.addEventListener('keydown', e => {
                if (e.key === 'Tab') {
                    if (e.shiftKey) { if (document.activeElement === first) { last.focus(); e.preventDefault(); } }
                    else { if (document.activeElement === last) { first.focus(); e.preventDefault(); } }
                }
            });
        }
    };

    const storage = {
        save: () => { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (e) { toast.warning('Could not save session.'); } },
        load: () => {
            const defaultState = { patterns:[], encounters:[], userEmotions:[{id:'default',name:'Neutral',color:'#808080'}], reflections:[], ui:{focusedPatternId:null} };
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                state = saved ? { ...defaultState, ...JSON.parse(saved), ui: { ...defaultState.ui, ...(JSON.parse(saved).ui || {}) } } : defaultState;
            } catch (e) {
                state = defaultState;
                toast.warning('Could not load previous session.');
            }
        }
    };

    const actions = {
        addPattern: (text) => { const s=sanitize(text); if(s){state.patterns.unshift({id:generateId(),text:s,originalText:s,status:'active',encounters:0});saveAndRender("Pattern Added");}},
        logEncounter: (pId, ctx, emoId) => { const p=state.patterns.find(p=>p.id===pId); if(!p)return; state.encounters.unshift({id:generateId(),patternId:pId,timestamp:new Date().toISOString(),context:ctx,emotionId:emoId,journal:'',flagged:false}); p.encounters=(p.encounters||0)+1; if(state.encounters.length>MAX_ENCOUNTERS)state.encounters.pop(); saveAndRender(); },
        updateEncounter: (id, ctx, emoId) => { const e=state.encounters.find(e=>e.id===id); if(e){e.context=ctx;e.emotionId=emoId;} saveAndRender("Encounter Updated"); },
        deleteEncounter: (id) => { if(!confirm("Delete encounter?"))return; const e=state.encounters.find(e=>e.id===id); if(!e)return; const p=state.patterns.find(p=>p.id===e.patternId); if(p)p.encounters=Math.max(0,p.encounters-1); state.encounters=state.encounters.filter(enc=>enc.id!==id); saveAndRender("Encounter Deleted","warning"); },
        retirePattern: (id) => { if(!confirm("Retire pattern?"))return; const p=state.patterns.find(p=>p.id===id); if(p){p.status='retired';p.retiredAt=new Date().toISOString();} saveAndRender("Pattern Retired","warning"); },
        reactivatePattern: (id) => { if(!confirm("Reactivate pattern?"))return; const p=state.patterns.find(p=>p.id===id); if(p)p.status='active'; saveAndRender("Pattern Reactivated"); },
        // ... Other actions are one-liners that call saveAndRender and optionally toast
    };

    const templates = {
        // All templates are functions that return HTML strings
        main: () => `<main class="container">...</main>`,
        patternCard: (p) => `...`,
        encounterCard: (e) => `...`,
        // etc.
    };

    const render = () => {
        elements.patternsContainer.innerHTML = renderPatterns();
        elements.encountersContainer.innerHTML = renderEncounters();
        setupIntersectionObserver();
    };
    const renderPatterns = () => { /* ... */ };
    const renderEncounters = () => { /* ... */ };

    const actionHandlers = {
        'add-pattern': () => { actions.addPattern(elements.patternInput.value); elements.patternInput.value = ''; },
        'log-encounter': (id) => modal.open({ title: `Log: ${state.patterns.find(p=>p.id===id)?.text}`, content: templates.log(state.patterns.find(p=>p.id===id)) }),
        'close-modal': () => modal.close(),
        // ... a complete map of all data-actions to their respective functions
    };
    
    function setupEventListeners() {
        document.body.addEventListener('click', e => {
            const target = e.target.closest('[data-action]');
            if (target) actionHandlers[target.dataset.action]?.(target.dataset.id, e);
        });
        document.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.stack.length > 0) modal.close(); });
    }

    function setupIntersectionObserver() {
        if (observers.has('patterns')) observers.get('patterns').disconnect();
        const observer = new IntersectionObserver(entries => {
            const mostVisible = entries.reduce((acc, entry) => entry.intersectionRatio > (acc?.intersectionRatio || 0) ? entry : acc, null);
            if (mostVisible?.target) {
                const focusedId = mostVisible.target.dataset.id;
                if (state.ui.focusedPatternId !== focusedId) {
                    state.ui.focusedPatternId = focusedId;
                    render();
                }
            }
        }, { root: elements.patternsContainer, threshold: 0.75 });
        elements.patternsContainer?.querySelectorAll('.pattern-card').forEach(card => observer.observe(card));
        observers.set('patterns', observer);
    }
    
    function init() {
        storage.load();
        elements.appContainer = document.getElementById('app-container');
        elements.appContainer.innerHTML = templates.main();
        Object.assign(elements, {
            modalContainer: document.getElementById('modal-container'),
            toastContainer: document.getElementById('toast-container'),
            patternsContainer: document.getElementById('patterns-container'),
            encountersContainer: document.getElementById('encounters-container'),
            patternInput: document.getElementById('pattern-input'),
        });
        setupEventListeners();
        render();
        if (state.patterns.length === 0) {
            setTimeout(() => toast.info('Welcome! Add a pattern to begin.', 5000), 1000);
        }
    }
    
    const saveAndRender = (toastMsg, toastType) => { storage.save(); render(); if(toastMsg) toast.show(toastMsg, toastType); };

    init();
});
</script>
</body>
</html>
